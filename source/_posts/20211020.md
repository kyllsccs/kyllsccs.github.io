---
title: Rust Note(3)_Variables I
date: 2021-10-20 07:29:46
categories: Rust
tags: Rust
---

> Rust 靜態語言, 透過自身的 Ownership System 去管理記憶體,  
> 有別於其他語言有 GC (Garbage Collector) 的方式.

<!--more-->

---

## 1. Setting variables 變數賦值

---

使用`let`關鍵字, 如下:

`Sample Code 1-1 變數賦值 let`

```rust
fn main() {
    let y : i64 = 10; // 設定變數y型別為整數型64位元, 值為10
    println!("The value of y is {}", y) // 印出y
}
```

`Output:`

```bash
$ cargo run
   Compiling rust_project v0.1.0 (D:\000_git_repo_projects\rust_project)
    Finished dev [unoptimized + debuginfo] target(s) in 0.50s
     Running `target\debug\rust_project.exe`
The value of y is 10
```

</span>

## 2. 變數重複賦值

---

> Compiler 直接拋出錯誤, `不可重複`對`不可變(不可改變值的變數)的變數`賦值  
> 範例 1-2

`Sample Code 2-1 重複賦值, compiler報錯`

```rust
fn main() {
    let y : i64 = 10; // 設定變數y型別為整數型64位元, 值為10
    println!("The value of y is {}", y) // 印出y
    y = 20;
    println!("The new value of y is {}", y)
}
```

`Output`

```bash
error[E0384]: cannot assign twice to immutable variable `y`
 --> src\main.rs:4:5
  |
2 |     let y : i64 = 10; // 設定變數y型別為整數型64位元, 值為10
  |         -
  |         |
  |         first assignment to `y`
  |         help: consider making this binding mutable: `mut y`
3 |     println!("The value of y is {}", y); // 印出y
4 |     y = 20;
  |     ^^^^^^ cannot assign twice to immutable variable

For more information about this error, try `rustc --explain E0384`.
error: could not compile `rust_project` due to previous error
```

> 看 terminal 輸出的訊息, 可把變數 y 的型態設定為 `mut (mutable)` 可變

`Sample Code 2-2 指定為可變變數 mut`

```rust
fn main() {
    let mut y : i64 = 10; // 設定變數y型別為整數型64位元, 值為10
    println!("The value of y is {}", y); // 印出y
    y = 20;
    println!("The new value of y is {}", y);
}
```

`Output`

```bash
$ cargo run
   Compiling rust_project v0.1.0 (D:\000_git_repo_projects\rust_project)
    Finished dev [unoptimized + debuginfo] target(s) in 0.37s
     Running `target\debug\rust_project.exe`
The value of y is 10
The new value of y is 20
```

> 告訴 compiler y 這是一個`可改變`的變數, 這樣就沒問題了.

## 3. 變數重新賦值

`重新賦值` 跟 `重複賦值` 不一樣定義

> 第一次變數賦值 : 把變數值存到 `heap 堆` 裡面  
> 第二次重新賦值 : 重新覆蓋在 `heap 堆` 裡面的值

`Sample Code 3-1 重新賦值, 比對上段 重複復職`

```rust
fn main() {
    let y : i64 = 10; // 設定變數y型別為整數型64位元, 值為10
    println!("The value of y is {}", y); // 印出y = 10
    let y : i64 = 20; // 重新賦值, 覆蓋過heap堆上的值, 重新取代
    println!("The new value of y is {}", y); // 印出y = 20
}
```

`Output`

```bash
$ cargo run
    Finished dev [unoptimized + debuginfo] target(s) in 0.00s
     Running `target\debug\rust_project.exe`
The value of y is 10
The new value of y is 20
```

> compiler 沒有報錯, 因為 y `重新` 被賦值

---

> 此時如果指定 y 為 `mut` 型態, compiler 就會出現`善意提醒`

`Sample Code 3-2 提醒mut為非必要`

```rust
fn main() {
    let mut y : i64 = 10; // 設定變數y型別為可變整數型64位元, 值為10
    println!("The value of y is {}", y); // 印出y = 10
    let y : i64 = 20; // 重新賦值, 覆蓋過heap堆上的值, 重新取代
    println!("The new value of y is {}", y); // 印出y = 20
}
```

`Output`

```bash
warning: variable does not need to be mutable
 --> src\main.rs:2:9
  |
2 |     let mut y : i64 = 10; // 設定變數y型別為可變整數型64位元, 值為10
  |         ----^
  |         |
  |         help: remove this `mut`
  |
  = note: `#[warn(unused_mut)]` on by default

warning: `rust_project` (bin "rust_project") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target\debug\rust_project.exe`
The value of y is 10
The new value of y is 20
```

> Compiler 一樣打印出值, 但是會提醒, `mut` 是不必要的.

## 4. 常數 (不可變) const

---

> 常數 : 意味著 不可變的, 賦值後, 不可做任何修改
> 宣告常數使用關鍵字 : `const <CONST_NAME>` : <CONST_NAME> 必須要大寫

`Sample Code 4-1 : 提醒大寫`

```rust
fn main() {
    const y : i64 = 10; // 設定常數y型別為整數型64位元, 值為10
    println!("The value of y is {}", y); // 印出y = 10
}
```

`Output`

```bash
   Compiling rust_project v0.1.0 (D:\000_git_repo_projects\rust_project)
warning: constant `y` should have an upper case name
 --> src\main.rs:2:11
  |
2 |     const y : i64 = 10; // 設定變數y型別為可變整數型64位元, 值為10
  |           ^ help: convert the identifier to upper case (notice the capitalization): `Y`
  |
  = note: `#[warn(non_upper_case_globals)]` on by default

warning: `rust_project` (bin "rust_project") generated 1 warning
    Finished dev [unoptimized + debuginfo] target(s) in 0.39s
     Running `target\debug\rust_project.exe`
The value of y is 10
```

> Compiler 提醒需要大寫, 但仍正常編譯

對常數重新賦值, compiler 報錯

`Sample Code 對常數重新賦值, 報錯`

```rust
fn main() {
    const Y : i64 = 10; // 設定常數y型別為整數型64位元, 值為10
    println!("The value of y is {}", Y); // 印出y = 10
    let Y : i64 = 20; // 重新賦值 報錯
    println!("{}", Y)
}
```

`Output`

```bash
error[E0005]: refutable pattern in local binding: `i64::MIN..=9_i64` and `11_i64..=i64::MAX` not covered
 --> src\main.rs:4:9
  |
2 |     const Y : i64 = 10; // 設定常數y型別為整數型64位元, 值為10
  |     ------------------- constant defined here
3 |     println!("The value of y is {}", Y); // 印出y = 10
4 |     let Y : i64 = 20;
  |         ^
  |         |
  |         interpreted as a constant pattern, not a new variable
  |         help: introduce a variable instead: `y_var`
  |
  = note: the matched value is of type `i64`

For more information about this error, try `rustc --explain E0005`.
error: could not compile `rust_project` due to previous error
```

> **const 常數** 為不可變動的值

</br>

## 5. 重點整理

---

-   宣告設定變數
    -   let : 一般變數
    -   const : 常數
-   變數可變
    -   mut : 可變, 不套用常數(const)

Rust Note_20211020
