---
title: Rust Note(7)_Stack & Heap
date: 2021-10-30 22:56:02
categories: Rust
tags: Rust
---

## Stack & Heap

棧 和 堆 的區別。

<!--more-->

### Stack 棧

---

> 有序的： `已被佔用` 且 `固定大小`。

棧是透過堆疊而成，採`Last in， first out` 概念(後進先出)。
意即在最剛開始就被賦予固定大小的值，且同時建立指針。
EX: `&str`;

> 應用在基本標量類型 ex `整數型`，`浮點數`...等

### Heap 堆

---

> 無序的：編譯時，`未知大小` 且 `可能大小變更`。

亦即在程式碼撰寫過程中，因應需要而賦予的值。  
只能透過`ptr (指針)` 來進行訪問。  
EX: `String`

> 應用在複合類型 ex `String`, `tuple`...等

### Pointer 指針

---

> 要訪問 `heap (無序的)` , 必須得透過 `Pointer (ptr: 指針)` 來進行訪問。

## 實際操作

---

> 基本數據類型 : 參考前面的筆記.

```rust
fn main() {
    let a: &str = "Hello world!";
    a.to_string().push_str(" KB Note!!!");
    println!("{}", a)
}

// output : Hello wolrd!
```

咦? 竟然沒有作用???

仔細的來看一下:

1. a 宣告為 `&str` 類型, 在 rust 裡面, 這屬於基本數據類型, 一旦成立, 直接被壓入 stack
2. 那既然是基本數據類型, 在成立的時候, 直接存入 stack, 若要去更動, 就要換成 String 類型.
3. 使用方法 to_string() : `&str` -- > `String`
4. 接著使用 push_str() 在後面加上字串.
5. 行不通?

What the hell??????

正確的順序應該是這樣:

```rust
fn main() {
    let a: &str = "Hello world!";
    let mut b = a.to_string();
    b.push_str(" KB Note!!!");
    println!("{}", b)
}

// output : Hello world! KB Note!!!
```

-   宣告 a 基本變量為 "Hello world!"
-   把 a 轉為 String, 並且賦予給 b , 模式設定為 `mut` 可變.
-   再利用 .push_str() 方式, 把 ` KB Note!!!` 加在字符串後端
-   在打印出 b 得到我們想要的結果.
-   此時的 a 仍是 "Hello world!"

在基本型態底下, 會比較令人迷惑的是 `&str` 跟 `String` 這兩種的轉換.

> 迷之聲 : `為什麼要搞得這麼麻煩?????`

基於 RUST 的最大賣點就是 `安全級系統語言`, 這還會跟後面的 `Ownership 所有權` 跟 `barrow 借用` 有著相對應重要的關係.

Rust Note 20211030_1.1
