<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>2019 Sep. 1st -2021 Sep. 12th 回顧</title>
    <url>/2021/09/12/2019-2021/</url>
    <content><![CDATA[<blockquote>
<p>Find it, know it, then solved it.<br>發現問題, 了解問題, 解決問題</p>
</blockquote>
<hr>
<p>那天夜黑風高的晚上~~~</p>
<p>(喂~~</p>
<span id="more"></span>

<p>這不是什麼恐怖故事齁, 只是要來寫寫我是怎開始踏入這<code>自學</code>的不歸路?!</p>
<p><code>2019 Sep 1st</code> 這輩子讓我難忘的日子?</p>
<p>在網路上查著哪一款語言最適合初學者… <del>我敢發誓我真的完全 0 經驗</del></p>
<blockquote>
<p><code>Python是適合新手的最佳語言</code> ???????</p>
</blockquote>
<p>說真的 : 我差點沒有崩潰…..</p>
<blockquote>
<p><del>表面上看似越簡單的, 其實才是真正的難</del></p>
</blockquote>
<br>
<br>
<br>

<p>型態? 是什麼?<br>宣告? 是什麼?<br>判斷? 是什麼?<br>迴圈? 是什麼?</p>
<br>  
<br>

<p>這些基礎中的基礎, 都不懂… 那更別談到什麼 <code>物件導向OOP</code></p>
<br>  
<br>  
其實當初賭的就是一口氣? 我就不信我看不懂!!!  
<br>
<br>  
<br>  
<br>  
~~但我看了一個月....我還是真的看不懂啊~~  
<br>
<br>
<br>

<blockquote>
<p>自從我吃了<del>撒尿牛 X</del>後, 我開始考試考 100 分?<br>抱歉, 中毒太深…</p>
</blockquote>
<p>就這樣像個小迷糊一樣的, 一邊工作一邊開始這跳坑之路?</p>
<br>  
<br>  
其實在我真正懂了這些...已經是隔 5 個月之後的事情了...
<br>

<p>真正讓我開竅的竟然是…….<code>Javascript</code> ??????????</p>
<br>  
<br>  
這又是另外一段故事了, 簡單的帶一下...

<p>算是幫新弄好的筆記紀錄做個處女秀?<br><br><br><br></p>
<p><code>下次有機會再來認真地分享一下我的自學之路????</code> 認真樣(握拳)</p>
]]></content>
      <categories>
        <category>Kylls MurMur</category>
      </categories>
      <tags>
        <tag>MurMur</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL基礎篇_MSSQL [一]</title>
    <url>/2021/09/14/20210913/</url>
    <content><![CDATA[<blockquote>
<p>Do it, find it, know it, and solved it, finally record it.</p>
</blockquote>
<hr>
<p>SQL 基礎篇</p>
<span id="more"></span>

<h3 id="基礎-SQL-查詢起手式"><a href="#基礎-SQL-查詢起手式" class="headerlink" title="基礎 SQL 查詢起手式"></a>基礎 SQL 查詢起手式</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">SELECT * FROM TABLE_NAME</span><br><span class="line">WHERE</span><br><span class="line">CONDITION_1 IS NULL</span><br><span class="line">AND</span><br><span class="line">CONDITION_2 &gt; 0</span><br><span class="line">AND</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p><code>SELECT</code> 是 SQL 查詢的起手式，<br><code>*</code> 代表是把所有的欄位名稱資料都撈出來<br><code>FROM</code> 從哪個 Table<br><code>TABLE_NAME</code> 是從哪個資料表<br><code>WHERE</code> 後面接的是判斷式的條件 AND / OR 等…</p>
<hr>
<h3 id="下-SQL-指令我可以用小寫嗎？"><a href="#下-SQL-指令我可以用小寫嗎？" class="headerlink" title="下 SQL 指令我可以用小寫嗎？"></a>下 SQL 指令我可以用小寫嗎？</h3><p>答案是<code>可以</code>的</p>
<p>我還特別的去查詢了一下一定要用大寫嗎？</p>
<p>答案是 有些資料庫為了避免大小寫的轉換影響效率 還是統一使用大寫好</p>
<hr>
<p>剛到做 ERP 的系統公司，說真的也是慢慢的從基本的語法開始練習…</p>
<p>剛開始哪知道什麼查詢不查詢的 <del>憑著熱愛打字的熱誠？</del></p>
<p>就開始了我的<code>奇幻ERP系統之旅</code> ?</p>
<blockquote>
<p>以前看著能夠在黑黑的螢幕不斷的鍵入指令很<code>帥</code>？！</p>
</blockquote>
<p><del>就這麼簡單的原因讓我欲罷不能…</del></p>
<h3 id="基本插入資料指令-INSERT-INTO"><a href="#基本插入資料指令-INSERT-INTO" class="headerlink" title="基本插入資料指令 INSERT INTO"></a>基本插入資料指令 INSERT INTO</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">INSERT INTO TABLE_NAME (COLUNM_1) VALUES (VALUE_1)</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>INSERT INTO</code> 插入…直接英文字義比較好記憶.<br><code>TABLE_NAME</code> 插入總有個目標吧，這個就是你的目標表格.<br><code>(COLUNM_1)</code> 這個就是裡面的欄位名稱，可以想成<code>excel</code>.<br><code>VALUES (VALUE_1)</code> 裡面就是對應的值</p>
<p>這邊要注意的是…欄位名稱跟值的順序位置是有對應的…<br>如果插入的順序錯了，or 插入的指定型態不一樣<br>資料庫就會吐紅紅地<code>error</code>給你看？！？！？！</p>
<hr>
<h3 id="基本更新指令-UPDATE-…-SET-…"><a href="#基本更新指令-UPDATE-…-SET-…" class="headerlink" title="基本更新指令 UPDATE … SET …"></a>基本更新指令 UPDATE … SET …</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">UPDATE TABLE_NAME SET COLUMN_1=VALUE_2</span><br><span class="line">WHERE</span><br><span class="line">CONDITION=VALUE_1</span><br><span class="line">AND</span><br><span class="line">....</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>UPDATE</code> 按照字面上的意思就是 更新啦…很好記吧.<br><code>SET</code> 就是設定的意思啦.</p>
<p>換個簡單的方式來記憶。</p>
<blockquote>
<p>就是把資料表裡面的某個欄位資料設定成你想要多資料。</p>
</blockquote>
<p>484 很好記</p>
<hr>
<h3 id="刪除指令-DELETE-FROM"><a href="#刪除指令-DELETE-FROM" class="headerlink" title="刪除指令 DELETE FROM"></a>刪除指令 DELETE FROM</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">DELETE FROM TABLE_NAME</span><br><span class="line">WHERE</span><br><span class="line">CONDITION=VALUE</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p><code>DELETE</code> 字面上就是刪除的意思<br><code>FROM</code> 從….哪裡的意思<br><code>WHERE</code> 放條件的地方，如果沒有放條件…~~~那就是全部刪除啦~~~</p>
<hr>
<p>簡單的紀錄一下。</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL_MSSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Note(2)_Data Type II</title>
    <url>/2021/10/17/20211017/</url>
    <content><![CDATA[<h2 id="Rsut-Note-2-Data-Types-II-Integer-Float"><a href="#Rsut-Note-2-Data-Types-II-Integer-Float" class="headerlink" title="Rsut Note(2) Data Types II Integer / Float"></a>Rsut Note(2) Data Types II Integer / Float</h2><p>依照 Data Type 的型別不同, 兩種方法:</p>
<ol>
<li>默認型別 : 直接使用系統默認</li>
<li>指定型別 : 透過 <code>:&lt;type&gt;</code> 指定型別</li>
</ol>
<span id="more"></span>

<h2 id="整數型-Integer"><a href="#整數型-Integer" class="headerlink" title="整數型 Integer"></a>整數型 Integer</h2></br>

<blockquote>
<p>Rust 默認為 i64</p>
</blockquote>
<p>Example_1: <strong>i8</strong> &gt;&gt; $2^7$-1 = 127, n=8, (n-1)=7, -1 就是扣掉 0<br>也就是如果型別指定為 i8, 可以接受的最大整數為 -128<del>0</del>127,<br>如超過 127 就會發生溢位</p>
<p>Example_2: <strong>u8</strong> &gt;&gt; $2^8$-1 = 255, n=8, -1 就是扣掉 0<br>也就是如果型別指定為 u8, 可以接受的最大整數為 0~255,<br>如超過 255 就會發生溢位</p>
<p>以下範例, 編譯器直接提醒:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">error: literal out of range <span class="keyword">for</span> `i8`</span><br><span class="line"> --&gt; src\main.rs:4:17</span><br><span class="line">  |</span><br><span class="line">4 |     <span class="built_in">let</span> x: i8 = 256;</span><br><span class="line">  |                 ^^^</span><br><span class="line">  |</span><br><span class="line">  = note: `<span class="comment">#[deny(overflowing_literals)]` on by default</span></span><br><span class="line">  = note: the literal `256` does not fit into the <span class="built_in">type</span> `i8` whose range is `-128..=127`</span><br><span class="line">  = <span class="built_in">help</span>: consider using the <span class="built_in">type</span> `i16` instead</span><br><span class="line"></span><br><span class="line">error: could not compile `rust_project` due to previous error</span><br></pre></td></tr></table></figure>

<h3 id="Rust-中的整型"><a href="#Rust-中的整型" class="headerlink" title="Rust 中的整型"></a>Rust 中的整型</h3><table>
<thead>
<tr>
<th>長度</th>
<th align="left">有符號</th>
<th align="left">無符號</th>
</tr>
</thead>
<tbody><tr>
<td>8 bits</td>
<td align="left">i8</td>
<td align="left">u8</td>
</tr>
<tr>
<td>16bits</td>
<td align="left">i16</td>
<td align="left">u16</td>
</tr>
<tr>
<td>32bits</td>
<td align="left">i32</td>
<td align="left">u32</td>
</tr>
<tr>
<td>64bits</td>
<td align="left">i64</td>
<td align="left">u64</td>
</tr>
<tr>
<td>128bits</td>
<td align="left">i128</td>
<td align="left">u128</td>
</tr>
<tr>
<td>arch</td>
<td align="left">isize</td>
<td align="left">usize</td>
</tr>
</tbody></table>
<p><code>i 代表有符號整數型: 可接受負數</code><br><code>u 代表無符號整數型: 不可接受負數</code> <strong>!</strong></p>
<blockquote>
<p>arch : 可以依照系統架構類型(x86 / x64), 直接判褖套用<code>默認型</code></p>
</blockquote>
</br>

<p>以下範例, 編譯器報錯:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> --&gt; src\main.rs:4:17</span><br><span class="line">  |</span><br><span class="line">4 |     <span class="built_in">let</span> x: u8 = -126;</span><br><span class="line">  |                 ^^^^ cannot apply unary operator `-`</span><br><span class="line">  |</span><br><span class="line">  = note: unsigned values cannot be negated</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0600`.</span><br><span class="line">error: could not compile `rust_project` due to previous error</span><br></pre></td></tr></table></figure>

</br>

<h2 id="浮點型-小數-Float"><a href="#浮點型-小數-Float" class="headerlink" title="浮點型 (小數) Float"></a>浮點型 (小數) Float</h2><blockquote>
<p>Rust 浮點型默認值為 : <code>f64</code></p>
</blockquote>
</br>

<p>浮點型只有兩種型態</p>
<ul>
<li>  <code>f32 : 單精度</code></li>
<li>  <code>f64 : 雙精度</code></li>
</ul>
<p>可以參考這邊 : <a href="https://zh.wikipedia.org/wiki/%E9%9B%99%E7%B2%BE%E5%BA%A6%E6%B5%AE%E9%BB%9E%E6%95%B8">單精度雙精度</a></p>
<p>Note : 20211017_v1.0</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Note(1)_Data Type I</title>
    <url>/2021/10/20/20211016/</url>
    <content><![CDATA[<h2 id="Rust-Note-1-Data-Types-I"><a href="#Rust-Note-1-Data-Types-I" class="headerlink" title="Rust Note(1) Data Types I"></a>Rust Note(1) Data Types I</h2><blockquote>
<p>Rust is a statically type language.<br>Rust 為一靜態型語言.</p>
</blockquote>
<span id="more"></span>

<hr>
<h3 id="靜態型"><a href="#靜態型" class="headerlink" title="靜態型"></a>靜態型</h3><blockquote>
<p>靜態型語言 :<br>靜態類型是一種編程語言特性，其中顯式聲明變量類型並因此在編譯時確定。<br>這讓編譯器可以決定給定的變量是否可以執行它所請求的操作。</p>
</blockquote>
</br>

<p>在進入編譯之前, 預先指定好資料的型別 (Example : 整數)<br></br><br>如果有需換類型: 則必須要做另外的轉換<br></br></p>
<h3 id="Rust-Date-Types"><a href="#Rust-Date-Types" class="headerlink" title="Rust Date Types"></a>Rust Date Types</h3><p><strong>Rust 基本 4 大型別</strong></p>
<ul>
<li>  int : 整數型</li>
<li>  float : 浮點型</li>
<li>  bool : 布林值 true / false</li>
<li>  string : 字串型</li>
</ul>
<h3 id="Rust-Variable-定義型別"><a href="#Rust-Variable-定義型別" class="headerlink" title="Rust Variable 定義型別"></a>Rust Variable 定義型別</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> x: <span class="built_in">String</span> = <span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p><code>&lt;Variable_name&gt;:&lt;DataType&gt;</code><br>冒號後面接的是資料型別</p>
</blockquote>
</br>

<hr>
<p>Rust Note 20211016</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Note(8)_Tuple Array Vector</title>
    <url>/2021/11/01/20211011-1/</url>
    <content><![CDATA[<h2 id="數據集合類型"><a href="#數據集合類型" class="headerlink" title="數據集合類型"></a>數據集合類型</h2><hr>
<p>除了單一基本數據類型，接著就是數據集合類型。</p>
<span id="more"></span>

<h2 id="Tuple-元組"><a href="#Tuple-元組" class="headerlink" title="Tuple 元組"></a>Tuple 元組</h2><hr>
<blockquote>
<p>用來儲存不一樣數據的類型，但其為不可改變。</p>
</blockquote>
<p>ex : (i64, &amp;str, f32, u64) : 需對應位置放入對應資料類型。</p>
<p>如需要在終端機輸出，則需要使用<code>&#123;:?&#125;</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> a: (<span class="built_in">i64</span>, &amp;<span class="built_in">str</span>, <span class="built_in">f32</span>) = (<span class="number">18</span>, <span class="string">&quot;Kylls&quot;</span>, <span class="number">0.76</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output : (18, &quot;Kylls&quot;, 0.76)</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  內容連續</li>
<li>  <code>不同數據類型</code></li>
<li>  不可變更</li>
<li>  輸出需用 <code>&#123;:?&#125;</code></li>
<li>  訪問元素位置直接使用 index , ex: a.0</li>
<li>  可當作 parameter 傳入 function</li>
<li>  可當 function 返回值</li>
</ul>
<h2 id="Array-陣列"><a href="#Array-陣列" class="headerlink" title="Array 陣列"></a>Array 陣列</h2><hr>
<blockquote>
<p>用來儲存相同數據類型資料，為內存連續區塊。</p>
</blockquote>
<p>ex: [i64; 3] : 此 Array 的長度為 3, 且內部元素數據類型為<code>i64</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> a: [<span class="built_in">i64</span>; <span class="number">3</span>] = [<span class="number">18</span>, <span class="number">20</span>, <span class="number">12</span>];</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output : [18, 20, 12]</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  內容連續</li>
<li>  <code>同數據類型</code></li>
<li><code>不可動態改變長度。</code><ul>
<li>  (如需改變則須做轉換，建議使用<code>Vector</code>可動態改變)</li>
</ul>
</li>
<li>  可變更, 但數據類型須符合。</li>
<li>  輸出需用 <code>&#123;:?&#125;</code></li>
<li>  訪問元素位置直接使用 index , ex: a.[1]</li>
<li>  可當作 parameter 傳入 function</li>
<li>  可當 function 返回值</li>
</ul>
<h2 id="Vector-向量陣列"><a href="#Vector-向量陣列" class="headerlink" title="Vector 向量陣列"></a>Vector 向量陣列</h2><hr>
<blockquote>
<p>用於儲存相同數據類型資料，為內存連續區塊。</p>
</blockquote>
<ul>
<li>  內容連續</li>
<li>  <code>同數據類型</code></li>
<li>  <code>可動態改變長度。</code></li>
<li>  可變更, 但數據類型須符合。</li>
<li>  輸出需用 <code>&#123;:?&#125;</code></li>
<li>  訪問元素位置直接使用 index , ex: a.[1]</li>
<li>  可當作 parameter 傳入 function</li>
<li>  可當 function 返回值</li>
</ul>
<h3 id="使用-vec-巨集方式建立向量"><a href="#使用-vec-巨集方式建立向量" class="headerlink" title="使用 vec! 巨集方式建立向量"></a>使用 vec! 巨集方式建立向量</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">vec!</span>[<span class="number">18</span>, <span class="number">20</span>, <span class="number">12</span>];</span><br><span class="line">        a.push(<span class="number">33</span>);</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output : [18, 20, 12, 33]</span></span><br></pre></td></tr></table></figure>

<h3 id="使用-new-方式建立"><a href="#使用-new-方式建立" class="headerlink" title="使用 new 方式建立"></a>使用 new 方式建立</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">Vec</span>::new();</span><br><span class="line">    a.push(<span class="number">1</span>);</span><br><span class="line">    a.push(<span class="number">2</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;:?&#125;&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output : [1, 2]</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>array 就類似 &amp;str<br>vector 就類似 String</p>
</blockquote>
<p>Rust Note_20211101_1.1</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Note(3)_Variables I</title>
    <url>/2021/10/20/20211020/</url>
    <content><![CDATA[<blockquote>
<p>Rust 靜態語言, 透過自身的 Ownership System 去管理記憶體,<br>有別於其他語言有 GC (Garbage Collector) 的方式.</p>
</blockquote>
<span id="more"></span>

<hr>
<h2 id="1-Setting-variables-變數賦值"><a href="#1-Setting-variables-變數賦值" class="headerlink" title="1. Setting variables 變數賦值"></a>1. Setting variables 變數賦值</h2><hr>
<p>使用<code>let</code>關鍵字, 如下:</p>
<p><code>Sample Code 1-1 變數賦值 let</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> y : <span class="built_in">i64</span> = <span class="number">10</span>; <span class="comment">// 設定變數y型別為整數型64位元, 值為10</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is &#123;&#125;&quot;</span>, y) <span class="comment">// 印出y</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Output:</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling rust_project v0.1.0 (D:\000_git_repo_projects\rust_project)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.50s</span><br><span class="line">     Running `target\debug\rust_project.exe`</span><br><span class="line">The value of y is 10</span><br></pre></td></tr></table></figure>

</span>

<h2 id="2-變數重複賦值"><a href="#2-變數重複賦值" class="headerlink" title="2. 變數重複賦值"></a>2. 變數重複賦值</h2><hr>
<blockquote>
<p>Compiler 直接拋出錯誤, <code>不可重複</code>對<code>不可變(不可改變值的變數)的變數</code>賦值<br>範例 1-2</p>
</blockquote>
<p><code>Sample Code 2-1 重複賦值, compiler報錯</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> y : <span class="built_in">i64</span> = <span class="number">10</span>; <span class="comment">// 設定變數y型別為整數型64位元, 值為10</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is &#123;&#125;&quot;</span>, y) <span class="comment">// 印出y</span></span><br><span class="line">    y = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The new value of y is &#123;&#125;&quot;</span>, y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Output</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error[E0384]: cannot assign twice to immutable variable `y`</span><br><span class="line"> --&gt; src\main.rs:4:5</span><br><span class="line">  |</span><br><span class="line">2 |     <span class="built_in">let</span> y : i64 = 10; // 設定變數y型別為整數型64位元, 值為10</span><br><span class="line">  |         -</span><br><span class="line">  |         |</span><br><span class="line">  |         first assignment to `y`</span><br><span class="line">  |         <span class="built_in">help</span>: consider making this binding mutable: `mut y`</span><br><span class="line">3 |     println!(<span class="string">&quot;The value of y is &#123;&#125;&quot;</span>, y); // 印出y</span><br><span class="line">4 |     y = 20;</span><br><span class="line">  |     ^^^^^^ cannot assign twice to immutable variable</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0384`.</span><br><span class="line">error: could not compile `rust_project` due to previous error</span><br></pre></td></tr></table></figure>

<blockquote>
<p>看 terminal 輸出的訊息, 可把變數 y 的型態設定為 <code>mut (mutable)</code> 可變</p>
</blockquote>
<p><code>Sample Code 2-2 指定為可變變數 mut</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> y : <span class="built_in">i64</span> = <span class="number">10</span>; <span class="comment">// 設定變數y型別為整數型64位元, 值為10</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is &#123;&#125;&quot;</span>, y); <span class="comment">// 印出y</span></span><br><span class="line">    y = <span class="number">20</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The new value of y is &#123;&#125;&quot;</span>, y);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Output</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">   Compiling rust_project v0.1.0 (D:\000_git_repo_projects\rust_project)</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.37s</span><br><span class="line">     Running `target\debug\rust_project.exe`</span><br><span class="line">The value of y is 10</span><br><span class="line">The new value of y is 20</span><br></pre></td></tr></table></figure>

<blockquote>
<p>告訴 compiler y 這是一個<code>可改變</code>的變數, 這樣就沒問題了.</p>
</blockquote>
<h2 id="3-變數重新賦值"><a href="#3-變數重新賦值" class="headerlink" title="3. 變數重新賦值"></a>3. 變數重新賦值</h2><p><code>重新賦值</code> 跟 <code>重複賦值</code> 不一樣定義</p>
<blockquote>
<p>第一次變數賦值 : 把變數值存到 <code>heap 堆</code> 裡面<br>第二次重新賦值 : 重新覆蓋在 <code>heap 堆</code> 裡面的值</p>
</blockquote>
<p><code>Sample Code 3-1 重新賦值, 比對上段 重複復職</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> y : <span class="built_in">i64</span> = <span class="number">10</span>; <span class="comment">// 設定變數y型別為整數型64位元, 值為10</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is &#123;&#125;&quot;</span>, y); <span class="comment">// 印出y = 10</span></span><br><span class="line">    <span class="keyword">let</span> y : <span class="built_in">i64</span> = <span class="number">20</span>; <span class="comment">// 重新賦值, 覆蓋過heap堆上的值, 重新取代</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The new value of y is &#123;&#125;&quot;</span>, y); <span class="comment">// 印出y = 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Output</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ cargo run</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.00s</span><br><span class="line">     Running `target\debug\rust_project.exe`</span><br><span class="line">The value of y is 10</span><br><span class="line">The new value of y is 20</span><br></pre></td></tr></table></figure>

<blockquote>
<p>compiler 沒有報錯, 因為 y <code>重新</code> 被賦值</p>
</blockquote>
<hr>
<blockquote>
<p>此時如果指定 y 為 <code>mut</code> 型態, compiler 就會出現<code>善意提醒</code></p>
</blockquote>
<p><code>Sample Code 3-2 提醒mut為非必要</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> y : <span class="built_in">i64</span> = <span class="number">10</span>; <span class="comment">// 設定變數y型別為可變整數型64位元, 值為10</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is &#123;&#125;&quot;</span>, y); <span class="comment">// 印出y = 10</span></span><br><span class="line">    <span class="keyword">let</span> y : <span class="built_in">i64</span> = <span class="number">20</span>; <span class="comment">// 重新賦值, 覆蓋過heap堆上的值, 重新取代</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The new value of y is &#123;&#125;&quot;</span>, y); <span class="comment">// 印出y = 20</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Output</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">warning: variable does not need to be mutable</span><br><span class="line"> --&gt; src\main.rs:2:9</span><br><span class="line">  |</span><br><span class="line">2 |     <span class="built_in">let</span> mut y : i64 = 10; // 設定變數y型別為可變整數型64位元, 值為10</span><br><span class="line">  |         ----^</span><br><span class="line">  |         |</span><br><span class="line">  |         <span class="built_in">help</span>: remove this `mut`</span><br><span class="line">  |</span><br><span class="line">  = note: `<span class="comment">#[warn(unused_mut)]` on by default</span></span><br><span class="line"></span><br><span class="line">warning: `rust_project` (bin <span class="string">&quot;rust_project&quot;</span>) generated 1 warning</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.39s</span><br><span class="line">     Running `target\debug\rust_project.exe`</span><br><span class="line">The value of y is 10</span><br><span class="line">The new value of y is 20</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Compiler 一樣打印出值, 但是會提醒, <code>mut</code> 是不必要的.</p>
</blockquote>
<h2 id="4-常數-不可變-const"><a href="#4-常數-不可變-const" class="headerlink" title="4. 常數 (不可變) const"></a>4. 常數 (不可變) const</h2><hr>
<blockquote>
<p>常數 : 意味著 不可變的, 賦值後, 不可做任何修改<br>宣告常數使用關鍵字 : <code>const &lt;CONST_NAME&gt;</code> : <CONST_NAME> 必須要大寫</p>
</blockquote>
<p><code>Sample Code 4-1 : 提醒大寫</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> y : <span class="built_in">i64</span> = <span class="number">10</span>; <span class="comment">// 設定常數y型別為整數型64位元, 值為10</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is &#123;&#125;&quot;</span>, y); <span class="comment">// 印出y = 10</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Output</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">   Compiling rust_project v0.1.0 (D:\000_git_repo_projects\rust_project)</span><br><span class="line">warning: constant `y` should have an upper <span class="keyword">case</span> name</span><br><span class="line"> --&gt; src\main.rs:2:11</span><br><span class="line">  |</span><br><span class="line">2 |     const y : i64 = 10; // 設定變數y型別為可變整數型64位元, 值為10</span><br><span class="line">  |           ^ <span class="built_in">help</span>: convert the identifier to upper <span class="keyword">case</span> (notice the capitalization): `Y`</span><br><span class="line">  |</span><br><span class="line">  = note: `<span class="comment">#[warn(non_upper_case_globals)]` on by default</span></span><br><span class="line"></span><br><span class="line">warning: `rust_project` (bin <span class="string">&quot;rust_project&quot;</span>) generated 1 warning</span><br><span class="line">    Finished dev [unoptimized + debuginfo] target(s) <span class="keyword">in</span> 0.39s</span><br><span class="line">     Running `target\debug\rust_project.exe`</span><br><span class="line">The value of y is 10</span><br></pre></td></tr></table></figure>

<blockquote>
<p>Compiler 提醒需要大寫, 但仍正常編譯</p>
</blockquote>
<p>對常數重新賦值, compiler 報錯</p>
<p><code>Sample Code 對常數重新賦值, 報錯</code></p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">const</span> Y : <span class="built_in">i64</span> = <span class="number">10</span>; <span class="comment">// 設定常數y型別為整數型64位元, 值為10</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;The value of y is &#123;&#125;&quot;</span>, Y); <span class="comment">// 印出y = 10</span></span><br><span class="line">    <span class="keyword">let</span> Y : <span class="built_in">i64</span> = <span class="number">20</span>; <span class="comment">// 重新賦值 報錯</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, Y)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>Output</code></p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error[E0005]: refutable pattern <span class="keyword">in</span> <span class="built_in">local</span> binding: `i64::MIN..=9_i64` and `11_i64..=i64::MAX` not covered</span><br><span class="line"> --&gt; src\main.rs:4:9</span><br><span class="line">  |</span><br><span class="line">2 |     const Y : i64 = 10; // 設定常數y型別為整數型64位元, 值為10</span><br><span class="line">  |     ------------------- constant defined here</span><br><span class="line">3 |     println!(<span class="string">&quot;The value of y is &#123;&#125;&quot;</span>, Y); // 印出y = 10</span><br><span class="line">4 |     <span class="built_in">let</span> Y : i64 = 20;</span><br><span class="line">  |         ^</span><br><span class="line">  |         |</span><br><span class="line">  |         interpreted as a constant pattern, not a new variable</span><br><span class="line">  |         <span class="built_in">help</span>: introduce a variable instead: `y_var`</span><br><span class="line">  |</span><br><span class="line">  = note: the matched value is of <span class="built_in">type</span> `i64`</span><br><span class="line"></span><br><span class="line">For more information about this error, try `rustc --explain E0005`.</span><br><span class="line">error: could not compile `rust_project` due to previous error</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong>const 常數</strong> 為不可變動的值</p>
</blockquote>
</br>

<h2 id="5-重點整理"><a href="#5-重點整理" class="headerlink" title="5. 重點整理"></a>5. 重點整理</h2><hr>
<ul>
<li>宣告設定變數<ul>
<li>  let : 一般變數</li>
<li>  const : 常數</li>
</ul>
</li>
<li>變數可變<ul>
<li>  mut : 可變, 不套用常數(const)</li>
</ul>
</li>
</ul>
<p>Rust Note_20211020</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Note(5)_if_else_match</title>
    <url>/2021/10/23/20211023-2/</url>
    <content><![CDATA[<h2 id="if-else-if-else-if-條件判斷"><a href="#if-else-if-else-if-條件判斷" class="headerlink" title="if else, if else if 條件判斷"></a>if else, if else if 條件判斷</h2><blockquote>
<p>如同其他語言一樣, Rust 也是有流程控制 <code>Control Condition Flow</code><br>使用的原則是, 只要有一個符合使用者所設定的條件, 那下方的判斷就不再執行.</p>
</blockquote>
<span id="more"></span>

<h2 id="if-else-若…則…"><a href="#if-else-若…則…" class="headerlink" title="if, else 若…則…"></a>if, else 若…則…</h2><blockquote>
<p>這是最簡單的, 若非 A 則 B.</p>
</blockquote>
<p>範例如下 :</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a: <span class="built_in">i64</span> = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">let</span> b: <span class="built_in">i64</span> = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">if</span> a != b &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;a is not equal to b!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;a is equal with b!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output : a is not equal to b!</span></span><br></pre></td></tr></table></figure>

<p>Flow 如下:</p>
<ol>
<li>先宣告兩個變數 a and b, 且指定其形態</li>
<li>做兩個對比比較</li>
<li><code>!=</code> 運算符 : 不等於</li>
<li><code>if &lt;condition 1&gt;</code> condition 1 條件滿足成立 <true> , 執行後面的運算</li>
<li>後面的 else 就不會再被執行</li>
</ol>
<p>修改一下上面的範例 :</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a: <span class="built_in">i64</span> = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">let</span> b: <span class="built_in">i64</span> = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">if</span> a == b &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;a is not equal to b!&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;a is equal with b!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output : a is equal with b!</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>把 <code>!=</code> 換成 <code>==</code><br>那結果就變成 if &lt;condition 1&gt; 不成立 <false>, 就繼續往下執行 else 語句</p>
</blockquote>
<p>當然, 世界如果有這麼美好就好了, 絕對不可能只有單純兩個判斷………..</p>
<p>那如果狀況很多呢? <code>How can I do?????????</code></p>
</br>

<h2 id="if-else-if-…-else-else-if-派上用場了"><a href="#if-else-if-…-else-else-if-派上用場了" class="headerlink" title="if, else if, …, else; else if 派上用場了!!!"></a>if, else if, …, else; <code>else if</code> 派上用場了!!!</h2><p>不囉嗦, 直接上範例</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a: <span class="built_in">i64</span> = <span class="number">32</span>;</span><br><span class="line">    <span class="keyword">let</span> b: <span class="built_in">i64</span> = <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">if</span> a == b &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;result 1&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> a &gt; b &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;result 2&quot;</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> a &gt;= b &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;result 3&quot;</span>)</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;result 4&quot;</span>)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output : result 4</span></span><br></pre></td></tr></table></figure>

<p>啾竟發生何事?</p>
<ol>
<li>宣告變數</li>
<li>開始條件判斷<br>2-1. &lt;condition 1&gt; : a 不等於 b <false><br>2-2. &lt;condition 2&gt; : a 大於 b <false><br>2-3. &lt;conditoin 3&gt; : a 大於等於 b <false></li>
<li>condition 1, 2, 3 都為 <code>false</code> 都不成立……..</li>
<li>所以最後輸出結果為 else 裡面的運算語句.</li>
</ol>
<blockquote>
<p>如果多了這麼多的條件判斷, 是不是可變化性變更多了?</p>
</blockquote>
<h2 id="Match-語句-Like-C-switch-語句"><a href="#Match-語句-Like-C-switch-語句" class="headerlink" title="Match 語句 (Like C switch 語句)"></a>Match 語句 (Like C switch 語句)</h2><blockquote>
<p>如果條件很多, 寫一大堆 if else…….是不是會更亂?????????</p>
</blockquote>
<p>那我們用 match 看看~</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> s_name: &amp;<span class="built_in">str</span> = <span class="string">&quot;KB&quot;</span>; <span class="comment">// Using &amp;str</span></span><br><span class="line">    <span class="keyword">let</span> f_name = <span class="keyword">match</span> s_name &#123;</span><br><span class="line">        <span class="string">&quot;KJ&quot;</span> =&gt; <span class="string">&quot;Kylls Jellies&quot;</span>,</span><br><span class="line">        <span class="string">&quot;KD&quot;</span> =&gt; <span class="string">&quot;Kylls Dellies&quot;</span>,</span><br><span class="line">        <span class="string">&quot;KB&quot;</span> =&gt; <span class="string">&quot;Kylls Bellies&quot;</span>,</span><br><span class="line">        _ =&gt; <span class="string">&quot;Unknown&quot;</span></span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Hi &#123;&#125;, Your name is &#123;&#125;.&quot;</span>, s_name, f_name);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output : Hi KB, Your name is Kylls Bellies.</span></span><br></pre></td></tr></table></figure>

<p>來看一下作用的 flow:</p>
<ol>
<li>f_name 有多個條件, “KJ”, “KD”, “KB”</li>
<li>使用 <code>match</code> 這關鍵字, 啟動媒合功能?????</li>
<li>只要裡面有對應到的, 就會<code>=&gt; 值</code>返回給 f_name</li>
<li><code>_ =&gt; value</code> 代表都比對不到, 那就返回 Unknown.</li>
</ol>
</br>

<p>有沒有發現 match 跟 C, Java 其他語言的 switch 很像呢?</p>
</br>

<p>Rust Note_20211023_1.2</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>SQL進階篇_MSSQL [双迴圈]</title>
    <url>/2021/10/18/20211018/</url>
    <content><![CDATA[<h2 id="SQL-双迴圈"><a href="#SQL-双迴圈" class="headerlink" title="SQL 双迴圈"></a>SQL 双迴圈</h2><span id="more"></span>

<ul>
<li>宣告變數<ul>
<li>  DECLARE @_EX INT</li>
</ul>
</li>
<li>設定變數值<ul>
<li>  SET @_EX = 10</li>
</ul>
</li>
<li>迴圈<ul>
<li>  WHILE (condition)</li>
</ul>
</li>
<li>起始&amp;結束<ul>
<li>  BEGIN &lt;作用域&gt; END</li>
</ul>
</li>
<li>設定指標<ul>
<li>  宣告指標 DECLARE BBB CURSOR FOR SELECT * FROM TABLE</li>
<li>  取得資料轉成變數 FETCH NEXT INTO @_VAR1</li>
</ul>
</li>
<li>指標關閉<ul>
<li>  關閉 CLOSE &lt;指標&gt;</li>
<li>  釋放記憶體 DEALLOCATE &lt;指標&gt;</li>
</ul>
</li>
<li>双迴圈 用巢狀方式撰寫<ul>
<li>  BEGIN BEGIN &lt;作用域&gt; END END</li>
</ul>
</li>
</ul>
<h2 id="範例程式碼"><a href="#範例程式碼" class="headerlink" title="範例程式碼"></a>範例程式碼</h2><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">--宣告變數型態</span></span><br><span class="line"><span class="keyword">DECLARE</span> @_BMIN <span class="type">INT</span></span><br><span class="line"><span class="keyword">DECLARE</span> @_BMAX <span class="type">INT</span></span><br><span class="line"><span class="keyword">DECLARE</span> @_CMIN <span class="type">INT</span></span><br><span class="line"><span class="keyword">DECLARE</span> @_CMAX <span class="type">INT</span></span><br><span class="line"><span class="keyword">DECLARE</span> @_BCNUM <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line"><span class="keyword">DECLARE</span> @_BSNUM <span class="type">VARCHAR</span>(<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">--(LEVEL 1)宣告指標變數</span></span><br><span class="line"><span class="keyword">DECLARE</span> BCUS_BCNUM <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> BCNUM <span class="keyword">FROM</span> dbo.BCUS <span class="keyword">WHERE</span> BCTYP<span class="operator">=</span><span class="string">&#x27;C&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">--(LEVEL 1)設定變數值</span></span><br><span class="line"><span class="keyword">SET</span> @_CMIN <span class="operator">=</span> <span class="number">0</span></span><br><span class="line"><span class="keyword">SET</span> @_CMAX <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(BCNUM) <span class="keyword">FROM</span> BCUS <span class="keyword">WHERE</span> BCTYP<span class="operator">=</span><span class="string">&#x27;C&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">OPEN</span> BCUS_BCNUM <span class="comment">--(LEVEL 1)開啟指標, 請求資料</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">--(LEVEL 1)WHILE迴圈起始結束值</span></span><br><span class="line">WHILE (@_CMIN <span class="operator">&lt;</span> @_CMAX)</span><br><span class="line"><span class="comment">--(LEVEL 1)BEGIN &lt;作用域&gt; END</span></span><br><span class="line"><span class="keyword">BEGIN</span></span><br><span class="line">	<span class="keyword">FETCH</span> NEXT <span class="keyword">FROM</span> BCUS_BCNUM <span class="keyword">INTO</span>	@_BCNUM <span class="comment">--(LEVEL 1) FETCH請求資料</span></span><br><span class="line">	<span class="comment">--(LEVEL 2)宣告指標變數</span></span><br><span class="line">	<span class="keyword">DECLARE</span> BSTO_BSNUM <span class="keyword">CURSOR</span> <span class="keyword">FOR</span> <span class="keyword">SELECT</span> BSNUM <span class="keyword">FROM</span> dbo.BSTO</span><br><span class="line">	<span class="comment">--(LEVEL 2)設定變數值</span></span><br><span class="line">	<span class="keyword">SET</span> @_BMIN <span class="operator">=</span> <span class="number">0</span></span><br><span class="line">	<span class="keyword">SET</span> @_BMAX <span class="operator">=</span> (<span class="keyword">SELECT</span> <span class="built_in">COUNT</span>(BSNUM) <span class="keyword">FROM</span> BSTO)</span><br><span class="line">	<span class="keyword">OPEN</span> BSTO_BSNUM <span class="comment">--(LEVEL 2)開啟指標, 請求資料</span></span><br><span class="line"></span><br><span class="line">	WHILE (@_BMIN <span class="operator">&lt;</span> @_BMAX) <span class="comment">--(LEVEL 2) WHILE迴圈起始結束值</span></span><br><span class="line">	<span class="keyword">BEGIN</span></span><br><span class="line">		<span class="keyword">FETCH</span> NEXT <span class="keyword">FROM</span> BSTO_BSNUM <span class="keyword">INTO</span>	@_BSNUM <span class="comment">--(LEVEL 2) FETCH 請求資料, 把資料變設定成變數</span></span><br><span class="line">		<span class="comment">--編寫指令, 裡面的VALUES數值用變數迭代</span></span><br><span class="line">		<span class="keyword">INSERT</span> <span class="keyword">INTO</span> dbo.BDZS (TRDAT,BSCLS,BSNUM,BSCTM,BSNUC,BSAVX)</span><br><span class="line">		<span class="keyword">VALUES</span> (<span class="string">&#x27;2021-10-18&#x27;</span>,<span class="string">&#x27;C&#x27;</span>,@_BSNUM,@_BCNUM,@_BSNUM,<span class="number">0</span>)</span><br><span class="line">		<span class="keyword">SET</span> @_BMIN <span class="operator">=</span> @_BMIN <span class="operator">+</span> <span class="number">1</span></span><br><span class="line">	<span class="keyword">END</span></span><br><span class="line">	<span class="keyword">CLOSE</span> BSTO_BSNUM　<span class="comment">--(LEVEL 2) 關閉指標</span></span><br><span class="line">	<span class="keyword">DEALLOCATE</span> BSTO_BSNUM <span class="comment">--(LEVEL 2) 釋放指標記憶體</span></span><br><span class="line">	<span class="keyword">SET</span> @_CMIN <span class="operator">=</span> @_CMIN <span class="operator">+</span> <span class="number">1</span></span><br><span class="line"><span class="keyword">END</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CLOSE</span> BCUS_BCNUM <span class="comment">--(LEVEL 1) 關閉指標</span></span><br><span class="line"><span class="keyword">DEALLOCATE</span> BCUS_BCNUM <span class="comment">--(LEVEL 1) 釋放指標記憶體</span></span><br><span class="line"></span><br><span class="line">GO</span><br></pre></td></tr></table></figure>

<p>SQL_NOTE : 20211018_1.1</p>
]]></content>
      <categories>
        <category>SQL</category>
      </categories>
      <tags>
        <tag>SQL_MSSQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Note(6)_loop for while</title>
    <url>/2021/10/25/20211025/</url>
    <content><![CDATA[<h2 id="Rust-迴圈"><a href="#Rust-迴圈" class="headerlink" title="Rust 迴圈"></a>Rust 迴圈</h2><blockquote>
<p>迴圈有以下 3 種類型 :</p>
<ul>
<li>  loop : 無限迴圈, 可藉由 break &amp; continue 來設定中斷點</li>
<li>  while : 在有效的條件裡, 迴圈!</li>
<li>  for…in range : 在設定的條件範圍內, 迴圈!</li>
</ul>
</blockquote>
<span id="more"></span>

<h2 id="loop-無限迴圈"><a href="#loop-無限迴圈" class="headerlink" title="loop [無限迴圈]"></a>loop [無限迴圈]</h2><hr>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> i: <span class="built_in">i64</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class="line">        i = i + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output : 1,2,3........until Ctrl+C inerrupt</span></span><br></pre></td></tr></table></figure>

<p>Working Flow:</p>
<ol>
<li>指定一個可變變數 i, <code>mut</code> 可變的</li>
<li>使用 loop</li>
<li>印出 i, 從 0 開始</li>
<li>結束一個循環後, i + 1</li>
<li>無限循環</li>
</ol>
<blockquote>
<p>在還沒有按下 Ctrl + C 前, 你會看到電腦努力的幫你執行一個無限迴圈!!</p>
</blockquote>
<h3 id="使用-break-來中斷-loop-迴圈"><a href="#使用-break-來中斷-loop-迴圈" class="headerlink" title="使用 [break] 來中斷 loop 迴圈"></a>使用 [break] 來中斷 loop 迴圈</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> i: <span class="built_in">i64</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class="line">        i = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> i &gt; <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output : 0~10</span></span><br></pre></td></tr></table></figure>

<p>Working Flow:</p>
<ol>
<li>指定一個可變變數 i, <code>mut</code> 可變的</li>
<li>使用 loop</li>
<li>印出 i, 從 0 開始</li>
<li>結束一個循環後, i + 1</li>
<li>當 i 累進到 &gt; 10, 就停止迴圈</li>
</ol>
<h3 id="使用-continue-讓-loop-繼續無腦迴圈"><a href="#使用-continue-讓-loop-繼續無腦迴圈" class="headerlink" title="使用 [continue] 讓 loop 繼續無腦迴圈"></a>使用 [continue] 讓 loop 繼續無腦迴圈</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> i: <span class="built_in">i64</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">loop</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>,i);</span><br><span class="line">        i = i + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> i == <span class="number">10</span> &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output : 0~9</span></span><br></pre></td></tr></table></figure>

<p>Working Flow:</p>
<ol>
<li>指定一個可變變數 i, <code>mut</code> 可變的</li>
<li>使用 loop</li>
<li>印出 i, 從 0 開始</li>
<li>結束一個循環後, i + 1</li>
<li>當 i 累進到 == 10, 就停止迴圈</li>
<li>否則 continue<br>P.S : 搭配 if else</li>
</ol>
</br>

<h2 id="while-條件式迴圈"><a href="#while-條件式迴圈" class="headerlink" title="while [條件式迴圈]"></a>while [條件式迴圈]</h2><hr>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> i:<span class="built_in">i64</span> = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> i &lt; <span class="number">10</span> &#123;</span><br><span class="line">        i = i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output : 0~10</span></span><br></pre></td></tr></table></figure>

<p>Working Flow:</p>
<ol>
<li>指定一個可變變數 i, <code>mut</code> 可變的</li>
<li>使用 while loop</li>
<li>印出 i, 從 0 開始</li>
<li>結束一個循環後, i + 1</li>
<li>當 i 累進到 &lt; 10, 就停止迴圈</li>
<li>while 後面接 condition 條件.</li>
</ol>
<blockquote>
<p>當滿足條件, 就停止迴圈.</p>
</blockquote>
<h2 id="for-in-範圍式迴圈"><a href="#for-in-範圍式迴圈" class="headerlink" title="for in [範圍式迴圈]"></a>for in [範圍式迴圈]</h2><hr>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="number">0</span>..<span class="number">10</span> &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, i)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output : 0~9</span></span><br></pre></td></tr></table></figure>

<p>Working Flow:</p>
<ol>
<li>使用 while loop</li>
<li>印出 i, 從 0 開始, 結束是 9 (包含左邊, 不包含右邊邊界)</li>
</ol>
<blockquote>
<p>當完成 range 裡面的次數, 就停止退出迴圈.</p>
</blockquote>
</br>

<p>Rust_Note_20211025_1.1</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Note(4)_Data Type III [String]</title>
    <url>/2021/10/23/20211023_1/</url>
    <content><![CDATA[<h2 id="Rust-字符串類型"><a href="#Rust-字符串類型" class="headerlink" title="Rust 字符串類型"></a>Rust 字符串類型</h2><hr>
<p>在 Rust 裡面, 字符串類型分以下兩種:</p>
<ul>
<li>  <code>&amp;str</code> : 字符串字面量</li>
<li>  <code>String</code> : 公開的 struct</li>
</ul>
<span id="more"></span>

<p>在這之前, 先來理解一個概念 <code>指針</code></p>
<blockquote>
<p>指針 : 在 C++裡面有一樣的概念<br>想成把方向指到一個記憶體位址, 也就是 Rust 裡面常常會看到有人說 <code>borrow</code> 借用的概念</p>
</blockquote>
<h3 id="借用-borrow"><a href="#借用-borrow" class="headerlink" title="借用 borrow"></a>借用 <code>borrow</code></h3><hr>
<blockquote>
<p>當一個變量被賦值成立, 也就代表被分配一個內存位址<br>當變數成立, 代表在記憶體中這個值是唯一, 不能去改變(除非設定為可變 mut), 不然只能<code>唯讀</code>.<br>那我們就是利用 <code>&amp;</code> 符號來借用<br>可借用的有 :</p>
<ul>
<li>  Type : 型態</li>
<li>  Value : 值 (可為字串/整數/福點數)</li>
</ul>
</blockquote>
<h2 id="amp-str-字符串字面量"><a href="#amp-str-字符串字面量" class="headerlink" title="&amp;str 字符串字面量"></a><code>&amp;str</code> 字符串字面量</h2><hr>
<blockquote>
<p><code>str</code> : 大小未知, 只能在指針後使用</p>
</blockquote>
<pre><code>也就是一個位址, 要把指針指到str的地方, 套用str的型態
</code></pre>
<blockquote>
<p>所以 str 都必須要與 <code>&amp;</code> 一起使用.</p>
</blockquote>
<p>範例 :</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a: &amp;<span class="built_in">str</span> = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output : Hello world</span></span><br></pre></td></tr></table></figure>

<p>如果沒有與 <code>&amp;</code> 連用</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a: <span class="built_in">str</span> = <span class="string">&quot;Hello world&quot;</span>;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>輸出報錯:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">error[E0277]: the size <span class="keyword">for</span> values of <span class="built_in">type</span> `str` cannot be known at compilation time</span><br><span class="line">   --&gt; src\main.rs:3:5</span><br><span class="line">    |</span><br><span class="line">3   |     println!(<span class="string">&quot;&#123;&#125;&quot;</span>, a)</span><br><span class="line">    |     ^^^^^^^^^^^^^^^^^ doesn<span class="string">&#x27;t have a size known at compile-time</span></span><br><span class="line"><span class="string">    |</span></span><br><span class="line"><span class="string">   ::: C:\Users\kylls\.rustup\toolchains\stable-x86_64-pc-windows-msvc\lib/rustlib/src/rust\library\core\src\fmt\mod.rs:294:20</span></span><br><span class="line"><span class="string">    |</span></span><br><span class="line"><span class="string">294 |     pub fn new&lt;&#x27;</span>b, T&gt;(x: &amp;<span class="string">&#x27;b T, f: fn(&amp;T, &amp;mut Formatter&lt;&#x27;</span>_&gt;) -&gt; Result) -&gt; ArgumentV1&lt;<span class="string">&#x27;b&gt; &#123;</span></span><br><span class="line"><span class="string">    |                    - required by this bound in `ArgumentV1::&lt;&#x27;</span>a&gt;::new`</span><br><span class="line">    |</span><br><span class="line">    = <span class="built_in">help</span>: the trait `Sized` is not implemented <span class="keyword">for</span> `str`</span><br><span class="line">    = note: this error originates <span class="keyword">in</span> the macro `<span class="variable">$crate</span>::format_args_nl` (<span class="keyword">in</span> Nightly builds, run with -Z macro-backtrace <span class="keyword">for</span> more info)</span><br></pre></td></tr></table></figure>

<p>看看 compiler 跟我們說的</p>
<blockquote>
<p>size 未知, 導致無法編譯</p>
</blockquote>
<p>也就是說, <code>沒有指針指到一個明確的記憶體位址</code></p>
</br>

<h2 id="String-字符串對象"><a href="#String-字符串對象" class="headerlink" title="String 字符串對象"></a><code>String</code> 字符串對象</h2><hr>
<p><code>OOP</code> 物件導向編程<br><code>String</code> 就是一個對象, 型態為<code>字符串</code></p>
<p>透過以下方法建立</p>
<ul>
<li>  <code>new</code></li>
<li>  <code>from</code></li>
</ul>
<p>先看 <code>new</code>的部分:</p>
<ol>
<li>直接 new 出一個記憶體空間(堆 heap) 來儲存</li>
<li>用 push_str 的方式, 從後段把字符添加上去</li>
</ol>
<p>Example:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> a = <span class="built_in">String</span>::new();</span><br><span class="line">    a.push_str(<span class="string">&quot;Hello world, you!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output : Hello world, you!</span></span><br></pre></td></tr></table></figure>

<p>再來看<code>from</code>的部分</p>
<ol>
<li>直接將字符串寫進去</li>
<li>同時間 compiler 會同步把字符串 new 出一個新的堆來儲存.</li>
</ol>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = <span class="built_in">String</span>::from(<span class="string">&quot;Hello you, world!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output : Hello you, world!</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>new 單純是一個字符字面上的量, 而 from 出來的是一個字符串的對象</p>
</blockquote>
</br>

<h2 id="字串操作"><a href="#字串操作" class="headerlink" title="字串操作"></a>字串操作</h2><hr>
<blockquote>
<p>如果要操作字串就必須要轉成<code>字符串對象</code></p>
</blockquote>
<ul>
<li>  to_string() : 轉換為字符串對象</li>
<li>  replace(a, b) : a 為要取代的字符, b 為取代的字符 a 替換成 b</li>
<li>  as_str() : 把字符對象轉為字符量 (from to new)</li>
<li>  push() : 原字符串後面追加</li>
<li>  push_str() : 功能同 push</li>
<li>  len() : 獲得字符串長度</li>
<li>  trim() : 去除字首字尾空白符號</li>
<li>  spilit_whitespace() : 以空白符作為分開依據</li>
<li>  split(“.”) : 以 <code>.</code> 為節點分開</li>
<li>  char() : 將字串打散為單一字符</li>
</ul>
<p>Rust_Note 20211023_1.1</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Note(7)_Stack &amp; Heap</title>
    <url>/2021/10/30/20211030-1/</url>
    <content><![CDATA[<h2 id="Stack-amp-Heap"><a href="#Stack-amp-Heap" class="headerlink" title="Stack &amp; Heap"></a>Stack &amp; Heap</h2><p>棧 和 堆 的區別。</p>
<span id="more"></span>

<h3 id="Stack-棧"><a href="#Stack-棧" class="headerlink" title="Stack 棧"></a>Stack 棧</h3><hr>
<blockquote>
<p>有序的： <code>已被佔用</code> 且 <code>固定大小</code>。</p>
</blockquote>
<p>棧是透過堆疊而成，採<code>Last in， first out</code> 概念(後進先出)。<br>意即在最剛開始就被賦予固定大小的值。<br>EX: <code>&amp;str</code>;</p>
<blockquote>
<p>應用在基本標量類型 ex <code>整數型</code>，<code>浮點數</code>…等</p>
</blockquote>
<h3 id="Heap-堆"><a href="#Heap-堆" class="headerlink" title="Heap 堆"></a>Heap 堆</h3><hr>
<blockquote>
<p>無序的：編譯時，<code>未知大小</code> 且 <code>可能大小變更</code>。</p>
</blockquote>
<p>亦即在程式碼撰寫過程中，因應需要而賦予的值。<br>只能透過<code>ptr (指針)</code> 來進行訪問。<br>EX: <code>String</code></p>
<blockquote>
<p>應用在複合類型 ex <code>String</code>, <code>tuple</code>…等</p>
</blockquote>
<h3 id="Pointer-指針"><a href="#Pointer-指針" class="headerlink" title="Pointer 指針"></a>Pointer 指針</h3><hr>
<blockquote>
<p>要訪問 <code>heap (無序的)</code> , 必須得透過 <code>Pointer (ptr: 指針)</code> 來進行訪問。</p>
</blockquote>
<h2 id="實際操作"><a href="#實際操作" class="headerlink" title="實際操作"></a>實際操作</h2><hr>
<blockquote>
<p>基本數據類型 : 參考前面的筆記.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a: &amp;<span class="built_in">str</span> = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    a.to_string().push_str(<span class="string">&quot; KB Note!!!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output : Hello wolrd!</span></span><br></pre></td></tr></table></figure>

<p>咦? 竟然沒有作用???</p>
<p>仔細的來看一下:</p>
<ol>
<li>a 宣告為 <code>&amp;str</code> 類型, 在 rust 裡面, 這屬於基本數據類型, 一旦成立, 直接被壓入 stack</li>
<li>那既然是基本數據類型, 在成立的時候, 直接存入 stack, 若要去更動, 就要換成 String 類型.</li>
<li>使用方法 to_string() : <code>&amp;str</code> – &gt; <code>String</code></li>
<li>接著使用 push_str() 在後面加上字串.</li>
<li>行不通?</li>
</ol>
<p>What the hell??????</p>
<p>正確的順序應該是這樣:</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a: &amp;<span class="built_in">str</span> = <span class="string">&quot;Hello world!&quot;</span>;</span><br><span class="line">    <span class="keyword">let</span> <span class="keyword">mut</span> b = a.to_string();</span><br><span class="line">    b.push_str(<span class="string">&quot; KB Note!!!&quot;</span>);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, b)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output : Hello world! KB Note!!!</span></span><br></pre></td></tr></table></figure>

<ul>
<li>  宣告 a 基本變量為 “Hello world!”</li>
<li>  把 a 轉為 String, 並且賦予給 b , 模式設定為 <code>mut</code> 可變.</li>
<li>  再利用 .push_str() 方式, 把 <code> KB Note!!!</code> 加在字符串後端</li>
<li>  在打印出 b 得到我們想要的結果.</li>
<li>  此時的 a 仍是 “Hello world!”</li>
</ul>
<p>在基本型態底下, 會比較令人迷惑的是 <code>&amp;str</code> 跟 <code>String</code> 這兩種的轉換.</p>
<blockquote>
<p>迷之聲 : <code>為什麼要搞得這麼麻煩?????</code></p>
</blockquote>
<p>基於 RUST 的最大賣點就是 <code>安全級系統語言</code>, 這還會跟後面的 <code>Ownership 所有權</code> 跟 <code>borrow 借用</code> 有著相對應重要的關係.</p>
<p>Rust Note 20211030_1.1</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Note(9)_Struct_implement</title>
    <url>/2021/11/05/20211105-1/</url>
    <content><![CDATA[<h2 id="struct-amp-struct-implement"><a href="#struct-amp-struct-implement" class="headerlink" title="struct &amp; struct implement"></a>struct &amp; struct implement</h2><p>用於組合並儲存不同類型的資料。</p>
<p>有別於 Array, Vector 只能存放同類型的資料，struct 提供了更加彈性的組合。</p>
<p>透過組合用法，可以達成類似其他語言，比如說 Python or Javascript 一樣，使用類似 class 的概念。</p>
<span id="more"></span>

<h2 id="struct-結構"><a href="#struct-結構" class="headerlink" title="[struct] 結構"></a>[struct] 結構</h2><hr>
<blockquote>
<p>使用關鍵字 ”struct” 來建立一個結構，並且指定型態。</p>
</blockquote>
<h3 id="程式碼"><a href="#程式碼" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">        width: <span class="built_in">u64</span>,</span><br><span class="line">        height: <span class="built_in">u64</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Working-Flow"><a href="#Working-Flow" class="headerlink" title="Working Flow"></a>Working Flow</h3><ul>
<li>  以 <code>struct</code> 關鍵字，開始建立結構</li>
<li>  賦予結構名稱，<code>首字母需大寫</code></li>
<li>建立的結構值在 <code>&#123;.........&#125;</code> 大括號這個作用域(scope)裡面。<ul>
<li>  賦予結構值名稱</li>
<li>  指定結構值型態 <code>: type</code>，<code>:</code> 賦予的意思</li>
<li>  不同結構值，中間以 <code>,</code> 隔開</li>
</ul>
</li>
</ul>
<h2 id="struct-初始化"><a href="#struct-初始化" class="headerlink" title="struct 初始化"></a>struct 初始化</h2><hr>
<blockquote>
<p>透過初始化 struct ，來達成使用 struct 的變數。</p>
</blockquote>
<h3 id="程式碼-1"><a href="#程式碼-1" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">        width: <span class="built_in">u64</span>,</span><br><span class="line">        height: <span class="built_in">u64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> rectangle_1 = Rectangle &#123;</span><br><span class="line">                width: <span class="number">80</span>,</span><br><span class="line">                height: <span class="number">30</span></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Rectangle 1 width is &#123;&#125;; height is &#123;&#125;.&quot;</span>,</span><br><span class="line">                       rectangle_1.width, rectangle_1.height)</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//output: Rectangle 1 width is 80; height is 30.</span></span><br></pre></td></tr></table></figure>

<h3 id="Working-Flow-1"><a href="#Working-Flow-1" class="headerlink" title="Working Flow"></a>Working Flow</h3><ul>
<li>使用<code>let</code> 來初始化 struct.<ul>
<li>  等號右邊必須要先跟 rust 說，你是要使用哪個 struct</li>
<li>  使用 <code>&#123;...&#125;</code> 包起來</li>
<li>  在 struct 裡面是指定型態，這邊就是指定值。</li>
<li>  各個值中間以<code>,</code> 隔開</li>
<li>  最後要記得加上 <code>;</code> 分隔符。</li>
<li>數值的型態如果沒有符合 struct 定義的，就會報錯。<ul>
<li>  ex: struct 宣告 type 為 u64, 但初始給值給 “Hello”</li>
<li>  “Hello” 為字串型態，與初始宣告 type 不符合</li>
</ul>
</li>
</ul>
</li>
<li>呼叫使用被初始化 struct 的值，使用<code>.</code>來進行呼叫<ul>
<li>  rectangle_1.width</li>
</ul>
</li>
</ul>
<h2 id="fn-呼叫套用-struct"><a href="#fn-呼叫套用-struct" class="headerlink" title="fn 呼叫套用 struct"></a>fn 呼叫套用 struct</h2><hr>
<blockquote>
<p>透過初始化 struct 之後, 可以利用 <code>.</code>來進行呼叫連接.</p>
</blockquote>
<p>如果要把 struct 當成 參數[parameter]來帶入應用呢? 答案是可以的…</p>
<h3 id="程式碼-2"><a href="#程式碼-2" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u64</span>,</span><br><span class="line">    height: <span class="built_in">u64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">rectangle_area</span></span>(rectangle: Rectangle) &#123;</span><br><span class="line">    <span class="keyword">let</span> area: <span class="built_in">u64</span> = rectangle.width * rectangle.height;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;This rectangle area is &#123;&#125;.&quot;</span>,area)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// give a value by using initial struct.</span></span><br><span class="line">    <span class="keyword">let</span> rectangle_1 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">99</span>,</span><br><span class="line">        height: <span class="number">88</span></span><br><span class="line">    &#125;;</span><br><span class="line">    rectangle_area(rectangle_1); <span class="comment">// Using function to caculate the area.</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output : This rectangle area is 8712.</span></span><br></pre></td></tr></table></figure>

<h3 id="Working-Flow-2"><a href="#Working-Flow-2" class="headerlink" title="Working Flow"></a>Working Flow</h3><ul>
<li>  定義一個 function : fn rectangle_area(){}</li>
<li>  設定 parameter - parameter 名為 rectangle - parameter 型別為 Rectangle - <code>fn rectangle_area(parameter_name: Struct_name)&#123;&#125;</code></li>
<li>  function 內部可直接使用 parameter_name.struct_name 來進行呼叫使用.</li>
<li>  連接一樣也是使用 <code>.</code></li>
</ul>
</br>

<h2 id="impl-implement-實作-–-具現化-實體操作"><a href="#impl-implement-實作-–-具現化-實體操作" class="headerlink" title="[impl] implement 實作 – 具現化 實體操作"></a>[impl] implement 實作 – 具現化 實體操作</h2><hr>
<blockquote>
<p>這是針對於 stuct 這個建構子 constructor 所制定專屬的方法.<br>想成實際的使用 constructor 所建立的專屬方法.<br>關鍵字就是 <code>impl</code> 英文單字: <code>implement</code> 實現</p>
</blockquote>
<h3 id="程式碼-3"><a href="#程式碼-3" class="headerlink" title="程式碼"></a>程式碼</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a struct, define the elements&#x27; name and type.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u64</span>,</span><br><span class="line">    height: <span class="built_in">u64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a method to implement the struct, the method is belong struct.</span></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u64</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.height * <span class="keyword">self</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// give a value by using initial struct.</span></span><br><span class="line">    <span class="keyword">let</span> rectangle_1 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">99</span>,</span><br><span class="line">        height: <span class="number">88</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;This rectangle width is &#123;&#125; cm, and the height is &#123;&#125; cm, and the are is &#123;&#125;&quot;</span>, rectangle_1.width, rectangle_1.height, rectangle_1.area());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output : This rectangle width is 99 cm, and the height is 88 cm, and the are is 8712</span></span><br></pre></td></tr></table></figure>

<h3 id="Working-Flow-3"><a href="#Working-Flow-3" class="headerlink" title="Working Flow"></a>Working Flow</h3><ul>
<li>  定義一個 impl struct_name : 用來實現這個 struct 的方法.</li>
<li>  impl Rectangle {定義方法}</li>
<li>  在 impl 內部, 可以有 function.</li>
<li>  fn 的 parameter 必須要是 <code>&amp;self</code></li>
<li>  &amp;self 的意思 : 自己引用自己, 也就是可以使用 struct 裡面的結構子, 利用呼叫自己 (self) 連接(.) 結構子</li>
<li>  後面應用就可以直接應用 .area() 來使用此被 實現化出來的專屬方法.</li>
</ul>
</br>

<h2 id="完整程式碼"><a href="#完整程式碼" class="headerlink" title="完整程式碼"></a>完整程式碼</h2><hr>
<blockquote>
<p>完整程式碼, 應用了兩種方式, 個別實現.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// Create a struct, define the elements&#x27; name and type.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Rectangle</span></span> &#123;</span><br><span class="line">    width: <span class="built_in">u64</span>,</span><br><span class="line">    height: <span class="built_in">u64</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a method to implement the struct, the method is belong struct.</span></span><br><span class="line"><span class="keyword">impl</span> Rectangle &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">area</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">u64</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">self</span>.height * <span class="keyword">self</span>.width</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a function to  caculate the rectangle area, and print area out.</span></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">rectangle_area</span></span>(rectangle: Rectangle) &#123;</span><br><span class="line">    <span class="keyword">let</span> area: <span class="built_in">u64</span> = rectangle.width * rectangle.height;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;This rectangle area is &#123;&#125;.&quot;</span>,area)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// give a value by using initial struct.</span></span><br><span class="line">    <span class="keyword">let</span> rectangle_1 = Rectangle &#123;</span><br><span class="line">        width: <span class="number">99</span>,</span><br><span class="line">        height: <span class="number">88</span></span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// using &#x27;.&#x27; to call value.</span></span><br><span class="line">            <span class="comment">// rectangle_1.area() is from struct method &quot;impl Rectangle&quot;</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;This rectangle width is &#123;&#125; cm, and the height is &#123;&#125; cm, and the are is &#123;&#125;&quot;</span>, rectangle_1.width, rectangle_1.height, rectangle_1.area());</span><br><span class="line">    rectangle_area(rectangle_1); <span class="comment">// Using function to caculate the area.</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Rust_note_20211110</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Note(11)_trait</title>
    <url>/2021/11/23/20211122-1/</url>
    <content><![CDATA[<h3 id="trait-特質介紹"><a href="#trait-特質介紹" class="headerlink" title="trait 特質介紹"></a>trait 特質介紹</h3><hr>
<blockquote>
<p>特質/特性 ： 這個是一個抽象的接口。<br>來接續上篇所說的抽象層的概念。</p>
</blockquote>
<span id="more"></span>

<p>上一篇提到的抽象層 Abstract layer 的概念<br>可以參閱 <a href="https://kyllsccs.github.io/2021/11/14/20211114-1-1/">Rust Note(10)</a></p>
<blockquote>
<p>把<code>共同特性</code>的特性集合起來，放在一個共同的地方，<br>讓有共同特性的物件 objects 可以透過呼叫這個接口，<br>來直接套用特性，<code>避免重複撰寫</code></p>
</blockquote>
<h3 id="struct-例子-1-vs-1"><a href="#struct-例子-1-vs-1" class="headerlink" title="struct 例子 (1 vs 1)"></a>struct 例子 (1 vs 1)</h3><p>前篇我們使用的是 <code>struct</code> 結構體，利用結構體把擁有共通特性的結構整併起來。</p>
<p>然後使用 <code>impl</code> <strong>implementation</strong> 來實作 struct，使其有專屬的 function！！！</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">User</span></span> &#123;</span><br><span class="line">    user_name: <span class="built_in">String</span>,</span><br><span class="line">    user_mail: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">impl</span> User &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">user_info</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;User name: &#123;&#125;  User mail:&#123;&#125;&quot;</span>, <span class="keyword">self</span>.user_name, <span class="keyword">self</span>.user_mail)</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> user_1 = User &#123;</span><br><span class="line">        user_name: <span class="built_in">String</span>::from(<span class="string">&quot;Kylls KB&quot;</span>),</span><br><span class="line">        user_mail: <span class="built_in">String</span>::from(<span class="string">&quot;kylls.ccs@gmail.com&quot;</span>)</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    user_1.user_info();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output : User name: Kylls KB  User mail: kylls.ccs@gmail.com</span></span><br></pre></td></tr></table></figure>

<p>以上是使用<code>struct</code>的例子</p>
<p>接著介紹另外一個方法<code>trait</code></p>
<h3 id="trait-例子-1-vs-2-3-…or-more…"><a href="#trait-例子-1-vs-2-3-…or-more…" class="headerlink" title="trait 例子 (1 vs 2?3?…or more…)"></a>trait 例子 (1 vs 2?3?…or more…)</h3><hr>
<blockquote>
<p>struct 用的是建構出共通的結構子 constructor<br>imp 是使用於實作方法(使用＆self 呼叫建構子)<br>一個<code>struct</code> &gt;&gt; 一個<code>impl</code> ……..<br>那如果多個<code>struct</code> 呢？？？<br>那還不狂寫一波？<br><br></p>
</blockquote>
<p><img src="https://www.niusnews.com/upload/imgs/default/16AugP/805kid/7.gif" alt="真的假的"></p>
<p>設計語言的利用抽象化的 trait<br><code>能夠越簡化代碼，就能夠減少重複撰寫，減少人為疏失</code></p>
<p>On the other words, simple is good.<br>就是越簡單&amp;&amp;越清楚越好！！！</p>
<h3 id="行為抽象化"><a href="#行為抽象化" class="headerlink" title="行為抽象化"></a>行為抽象化</h3><figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">People</span></span> &#123;</span><br><span class="line">    name: <span class="built_in">String</span>,</span><br><span class="line">    age: <span class="built_in">u64</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 建立方法抽象層</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Action</span></span> &#123;</span><br><span class="line">    <span class="comment">// function do 返回不指定，可自定義</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">say_hello</span></span>(&amp;<span class="keyword">self</span>);</span><br><span class="line">    <span class="comment">// function can_do 返回 true or false</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_do</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 實作方法 by using trait for struct</span></span><br><span class="line"><span class="comment">// 同樣性質的trait, 可以用來實作多個結構體,</span></span><br><span class="line"><span class="comment">// 使用 `for` -&gt; 專屬哪個struct</span></span><br><span class="line"><span class="keyword">impl</span> Action <span class="keyword">for</span> People &#123;</span><br><span class="line">    <span class="comment">// &amp;self 使用自己的意思</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">say_hello</span></span>(&amp;<span class="keyword">self</span>) &#123;</span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Hello, my name is &#123;&#125;.&quot;</span>, <span class="keyword">self</span>.name)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 注意返回是boolean</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">can_do</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">self</span>.age &lt; <span class="number">50</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">        <span class="keyword">let</span> people_1 = People &#123;</span><br><span class="line">                <span class="comment">// new 一個新的String出來</span></span><br><span class="line">                name: <span class="built_in">String</span>::from(<span class="string">&quot;Kylls&quot;</span>),</span><br><span class="line">                age: <span class="number">18</span>,</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">println!</span>(<span class="string">&quot;Can &#123;&#125; speak? &#123;&#125;&quot;</span>, people_1.name, people_1.can_do());</span><br><span class="line">        <span class="comment">// output: Can Kylls speak? true</span></span><br><span class="line">        people_1.say_hello();</span><br><span class="line">        <span class="comment">// output: Hello, my name is Kylls.</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>描述擁有的共同架構，集合成<code>struct</code><br>描述相同行為的動作，集合成<code>trait</code></p>
</blockquote>
<p>更進一步的敘述出 <code>物件會有的行為特質</code></p>
<p>Rust Note_20211122</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Note(13)_enum(II) with struct</title>
    <url>/2021/11/25/20211125-1/</url>
    <content><![CDATA[<h3 id="enum-基本型"><a href="#enum-基本型" class="headerlink" title="enum 基本型"></a>enum 基本型</h3><hr>
<blockquote>
<p>enum 基本型請參閱 <a href="https://kyllsccs.github.io/2021/11/24/20211124-1/">Rust Note(12)_enum(I)</a></p>
</blockquote>
<span id="more"></span>

<h3 id="enum-變化型-w-struct"><a href="#enum-變化型-w-struct" class="headerlink" title="enum 變化型 w/ struct"></a>enum 變化型 w/ struct</h3><hr>
<blockquote>
<p>struct 裡面的 constructor 結構子型態直接指定為 enum 裡面的變數. <br></p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 枚舉出星期幾</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span></span> &#123;</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday,</span><br><span class="line">    Sunday,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// new 一個 struct, constructor 結構子型態為 enum</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Weekday</span></span> &#123;</span><br><span class="line">    <span class="comment">// struct Weekday 的 constructor weekd 的type 為 enum Day</span></span><br><span class="line">    weekd: Day</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// impl Weekday</span></span><br><span class="line"><span class="keyword">impl</span> Weekday &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">def_day</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="comment">// 做 match self.weekd self要明確地指出要match哪一個constructor</span></span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span>.weekd &#123;</span><br><span class="line">            Day::Saturday | Day::Sunday =&gt; <span class="keyword">return</span> <span class="string">&quot;The day is holiday.&quot;</span>,</span><br><span class="line">            _ =&gt; <span class="keyword">return</span> <span class="string">&quot;The day is working day.&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> a = Weekday &#123;</span><br><span class="line">        <span class="comment">// 可直接取 enum Day裡面的值</span></span><br><span class="line">        weekd: Day::Sunday</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125;&quot;</span>, a.def_day());</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output : The day is holiday.</span></span><br></pre></td></tr></table></figure>

<p>Working flow:</p>
<ul>
<li>  先把可能的型態枚舉出來 (enum)</li>
<li>  把 enum 型態做成對應的 struct 裡面的 constructors</li>
<li>針對 struct 實作 impl<ul>
<li>  實作 a function daf_day</li>
<li>  <code>&amp;self</code> 呼叫可套用自己 struct 的參數</li>
<li>  使用 match XXX {}</li>
<li>  要 match 哪個值 –&gt; self.weekd 自己內部的 constructor, 使用<code>.</code>做呼叫</li>
<li>  <code>|</code> operator 運算子</li>
<li><code>=&gt;</code> 後面接 return XXXXX<ul>
<li>  return XXXXX 的 type 要跟 function 起頭的 -&gt; type 呼應</li>
</ul>
</li>
<li>  <code>_ =&gt; return</code> 除了指定的比對, 其餘的使用下底線代替</li>
</ul>
</li>
<li>回到執行 function main<ul>
<li>  宣告 a 來自於 struct Weekday</li>
<li>  賦予 weekd 的型態值為 Day::Sunday</li>
<li>  println!() 輸出看結果</li>
</ul>
</li>
</ul>
<p>Rust Note(13)_20211125</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Note(10)_Abtract Concept 抽象化概念</title>
    <url>/2021/11/14/20211114-1-1/</url>
    <content><![CDATA[<h3 id="Abstract-抽象化"><a href="#Abstract-抽象化" class="headerlink" title="Abstract 抽象化"></a>Abstract 抽象化</h3><blockquote>
<p>理解<code>抽象化</code>概念剛好可以利用 struct 來做理解.</p>
</blockquote>
<p><strong>結構體詳細介紹請參閱前一篇</strong> : <a href="https://kyllsccs.github.io/2021/11/05/20211105-1/">Rust Note(9)</a></p>
<span id="more"></span>

<blockquote>
<p>利用結構體 (struct) 創造出不一樣 types 的儲存體.</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Fruits</span></span> &#123;</span><br><span class="line">    <span class="comment">// Using struct to build a new struct in &#123;...&#125;, and consign constructor name and :type</span></span><br><span class="line">    fruit_name: <span class="built_in">String</span>,</span><br><span class="line">    fruit_color: <span class="built_in">String</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// init the struct</span></span><br><span class="line">    <span class="keyword">let</span> apple = Fruits &#123;</span><br><span class="line">        fruit_name: <span class="built_in">String</span>::from(<span class="string">&quot;Apple&quot;</span>),</span><br><span class="line">        fruit_color: <span class="built_in">String</span>::from(<span class="string">&quot;red&quot;</span>),</span><br><span class="line">    &#125;; <span class="comment">// 記得添加分號</span></span><br><span class="line">    <span class="keyword">let</span> banana = Fruits &#123;</span><br><span class="line">        fruit_name: <span class="built_in">String</span>::from(<span class="string">&quot;Banana&quot;</span>),</span><br><span class="line">        fruit_color: <span class="built_in">String</span>::from(<span class="string">&quot;yellow&quot;</span>),</span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="comment">// 使用 . 來進行呼叫</span></span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is &#123;&#125;&quot;</span>, apple.fruit_name, apple.fruit_color);</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;&#123;&#125; is &#123;&#125;&quot;</span>, banana.fruit_name, banana.fruit_color);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// output: Apple is red</span></span><br><span class="line"><span class="comment">// output: Banana is yellow</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p><font color=#FF00FF>代碼重複性利用程度越高, 重複撰寫同樣代碼就少, 這樣也可以降低出錯的機會.</font></p>
</blockquote>
<font color=#800080>
稍微想像一下, apple & banana 有什麼共同點?

<ul>
<li>  同樣都是水果</li>
<li>同樣都是有顏色的水果 (廢話, 有透明的水果嗎?(#ﾟ Д ﾟ))  </font></li>
</ul>
<blockquote>
<p>如果今天遇到 apple, 就寫一次 apple 的物件…</p>
<blockquote>
<p>下次遇到 banana, 就再寫一次 banana 的物件…</p>
<blockquote>
<p>再下次遇到 lemon, 那就再寫一次 lemon 的物件…</p>
<blockquote>
<p>如果今天遇到 7749 個水果…那不就寫到天荒地老…<br>阿是夠了沒…………(／‵Д′)／~ ╧╧<br> ……</p>
</blockquote>
</blockquote>
</blockquote>
</blockquote>
<p><img src="https://www.niusnews.com/upload/imgs/default/16AugP/805kid/3.gif" alt="冰的啦"></p>
<hr>
<blockquote>
<p>把共通點列出來, 做成<code>抽象層</code>, 那我們就可以利用這個抽象層來呼叫.</p>
</blockquote>
<p>以上面 <code>struct Fruits </code> 的例子來說, 裡面包含了:</p>
<ol>
<li>水果名稱</li>
<li>水果顏色</li>
</ol>
<p>今天遇到了蘋果:</p>
<ul>
<li>apple<ul>
<li>  fruit_name: apple</li>
<li>  fruit_color: red</li>
</ul>
</li>
</ul>
<p>今天遇到了香蕉:</p>
<ul>
<li>banana<ul>
<li>  fruit_name: banana</li>
<li>  fruit_color: yellow</li>
</ul>
</li>
</ul>
<p>如果遇到火龍果:</p>
<ul>
<li>火龍果<ul>
<li>  fruit_name: 火龍果</li>
<li>  fruit_color: 紅色</li>
</ul>
</li>
</ul>
<p>有沒有發現大大的縮短創造物件的時間? 利用共通特性…<br>同時也可以避免出錯.</p>
<p>Rust_Note_20211114(1)</p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Note(12) enum(I)</title>
    <url>/2021/11/24/20211124-1/</url>
    <content><![CDATA[<h3 id="enum-enumeration-枚舉"><a href="#enum-enumeration-枚舉" class="headerlink" title="enum (enumeration) 枚舉"></a>enum (enumeration) 枚舉</h3><hr>
<p>另外一種型態的<code>類似</code> struct 結構體概念。<br>不完全相同，也不完全不同。</p>
<span id="more"></span>

<h3 id="struct-結構體"><a href="#struct-結構體" class="headerlink" title="struct 結構體"></a>struct 結構體</h3><hr>
<p>複習一下<code>struct</code> 的概念</p>
<blockquote>
<p>用於結構化一個物件，將其特性&amp;&amp;型態標示出來。<br>可用 <code>impl</code> 來對 struct 構建方法並使用結構體裡面的參數。</p>
</blockquote>
<p>…</p>
<h3 id="enum-枚舉"><a href="#enum-枚舉" class="headerlink" title="enum 枚舉"></a>enum 枚舉</h3><hr>
<blockquote>
<p>把可能的對象一一的舉例，就是<code>枚舉</code><br>等同 struct, 可用<code>impl</code> 實作方法。</p>
</blockquote>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 把一週天都枚舉出來</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span></span> &#123;</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday,</span><br><span class="line">    Sunday,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 實作Day</span></span><br><span class="line"><span class="keyword">impl</span> Day &#123;</span><br><span class="line">     <span class="comment">// 返回true or false</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">is_weekday</span></span>(&amp;<span class="keyword">self</span>) -&gt; <span class="built_in">bool</span> &#123;</span><br><span class="line">        <span class="comment">// 使用 match, 匹配自己</span></span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="comment">// 使用運算符  |  or 只要有一個條件成立，即為true</span></span><br><span class="line">            &amp;Day::Saturday | &amp;Day::Sunday =&gt; <span class="keyword">return</span> <span class="literal">false</span>,</span><br><span class="line">            _ =&gt; <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">        <span class="comment">// `_` other的意思</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="comment">// 賦值 d</span></span><br><span class="line">    <span class="keyword">let</span> d = Day::Sunday;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Is d weekday? &#123;&#125;&quot;</span>, d.is_weekday());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: Is d weekday? false</span></span><br></pre></td></tr></table></figure>

<p>簡單的搭配 <code>match</code> , 簡化了 if else 判斷。</p>
<h3 id="使用-trait-for-enum"><a href="#使用-trait-for-enum" class="headerlink" title="使用 trait for enum"></a>使用 trait for enum</h3><hr>
<p>那可以搭配 trait ?<br>可以的</p>
<figure class="highlight rust"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  把實例枚舉出來</span></span><br><span class="line"><span class="meta">#[derive(Debug)]</span></span><br><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">Day</span></span> &#123;</span><br><span class="line">    Monday,</span><br><span class="line">    Tuesday,</span><br><span class="line">    Wednesday,</span><br><span class="line">    Thursday,</span><br><span class="line">    Friday,</span><br><span class="line">    Saturday,</span><br><span class="line">    Sunday,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 抽象化一層特質(trait) 為動作</span></span><br><span class="line"><span class="class"><span class="keyword">trait</span> <span class="title">Action</span></span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">actl</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">str</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 實作 impl</span></span><br><span class="line"><span class="keyword">impl</span> Action <span class="keyword">for</span> Day &#123;</span><br><span class="line">    <span class="comment">// return &amp;str type</span></span><br><span class="line">    <span class="function"><span class="keyword">fn</span> <span class="title">actl</span></span>(&amp;<span class="keyword">self</span>) -&gt; &amp;<span class="built_in">str</span> &#123;</span><br><span class="line">        <span class="comment">// match self</span></span><br><span class="line">        <span class="keyword">match</span> <span class="keyword">self</span> &#123;</span><br><span class="line">            <span class="comment">// by using | or operator</span></span><br><span class="line">            &amp;Day::Saturday | &amp;Day::Sunday =&gt; <span class="string">&quot;I sleep all day!&quot;</span>,</span><br><span class="line">            <span class="comment">// &quot;_&quot; equal the other</span></span><br><span class="line">            _ =&gt; <span class="string">&quot;I must work hard.&quot;</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">fn</span> <span class="title">main</span></span>() &#123;</span><br><span class="line">    <span class="keyword">let</span> today = Day::Monday;</span><br><span class="line">    <span class="keyword">let</span> other_day = Day::Sunday;</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Today is &#123;:?&#125;, &#123;&#125;&quot;</span>, today, today.actl());</span><br><span class="line">    <span class="built_in">println!</span>(<span class="string">&quot;Tomorrow is &#123;:?&#125;, &#123;&#125;.&quot;</span>, other_day, other_day.actl());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// output: Today is Monday, I must work hard.</span></span><br><span class="line"><span class="comment">// output: Tomorrow is Sunday, I sleep all day.</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>下一篇加入一點點不一樣的連結轉變.</p>
<p>Rust Note_20211125 for <code>enum(I)</code></p>
]]></content>
      <categories>
        <category>Rust</category>
      </categories>
      <tags>
        <tag>Rust</tag>
      </tags>
  </entry>
  <entry>
    <title>Rust Note_Season(I)_List</title>
    <url>/2021/11/28/20211128-1/</url>
    <content><![CDATA[<h3 id="Rust-Basic-基礎總結"><a href="#Rust-Basic-基礎總結" class="headerlink" title="Rust Basic 基礎總結"></a>Rust Basic 基礎總結</h3><hr>
<blockquote>
<p>Rust Season (I) 總整理…<br></p>
</blockquote>
<span id="more"></span>

<h3 id="Rust-Note-Season-I-List"><a href="#Rust-Note-Season-I-List" class="headerlink" title="Rust Note Season I _List"></a>Rust Note Season I _List</h3><hr>
<ol>
<li><a href="https://kyllsccs.github.io/2021/10/20/20211016/">Rust Note(1) Data Types I</a><ul>
<li><code>Rust</code>裡的基本型態, 如何設定型態</li>
</ul>
</li>
<li><a href="https://kyllsccs.github.io/2021/10/17/20211017/">Rust Note(2)_Data Type II</a><ul>
<li><code>Rust</code>裡的基本型態, 如何設定型態 II</li>
</ul>
</li>
<li><a href="https://kyllsccs.github.io/2021/10/20/20211020/">Rust Note(3)_Variables I</a><ul>
<li><code>Rust</code> 變數的定義</li>
</ul>
</li>
<li><a href="https://kyllsccs.github.io/2021/10/23/20211023_1/">Rust Note(4)_Data Type III [String]</a><ul>
<li><code>Rust</code> String and &amp;str 區別定義</li>
</ul>
</li>
<li><a href="https://kyllsccs.github.io/2021/10/23/20211023-2/">Rust Note(5)_if_else_match</a><ul>
<li><code>Rust</code> if else 控制流 + match 匹配作用功能</li>
</ul>
</li>
<li><a href="https://kyllsccs.github.io/2021/10/25/20211025/">Rust Note(6)_loop for while</a><ul>
<li><code>Rust</code> 迴圈介紹</li>
</ul>
</li>
<li><a href="https://kyllsccs.github.io/2021/10/30/20211030-1/">Rust Note(7)_Stack &amp; Heap</a><ul>
<li><code>Rust</code> 堆與棧的區別, 指針概念 C++</li>
</ul>
</li>
<li><a href="https://kyllsccs.github.io/2021/11/01/20211011-1/">Rust Note(8)_Tuple Array Vector</a><ul>
<li><code>Rust</code> 元組 &amp;&amp; 數組 &amp;&amp; 向量, 用來儲存資料的方式</li>
</ul>
</li>
<li><a href="https://kyllsccs.github.io/2021/11/05/20211105-1/">Rust Note(9)_Struct_implement</a><ul>
<li><code>Rust</code> 結構體 struct &amp;&amp; 結構體裡面的結構子 constructor &amp;&amp; 把結構體拿來實作的方法 implement</li>
</ul>
</li>
<li><a href="https://kyllsccs.github.io/2021/11/14/20211114-1-1/">Rust Note(10)_Abtract Concept 抽象化概念</a><ul>
<li><code>Rust</code> 抽象化概念學習</li>
</ul>
</li>
<li><a href="https://kyllsccs.github.io/2021/11/23/20211122-1/">Rust Note(11)_trait</a><ul>
<li><code>Rust</code> 特質, 搭配 struct 結構體, 另外抽象化</li>
</ul>
</li>
<li><a href="https://kyllsccs.github.io/2021/11/24/20211124-1/">Rust Note(12) enum(I)</a><ul>
<li><code>Rust</code> 枚舉 enum 舉例出實例, 並且呼叫套用 (I)</li>
</ul>
</li>
<li><a href="https://kyllsccs.github.io/2021/11/25/20211125-1/">Rust Note(13)_enum(II) with struct</a><ul>
<li><code>Rust</code> 枚舉 enum 舉例出實例, 並且呼叫套用 &amp;&amp; 結合 struct 產生關聯 (II)</li>
</ul>
</li>
</ol>
<h3 id="Rust-Note-Season-II"><a href="#Rust-Note-Season-II" class="headerlink" title="Rust Note Season II"></a>Rust Note Season II</h3><hr>
<p>趁著把之前所有筆記統整一下, 安排規劃接下來的學習計畫:</p>
<ul>
<li>  泛型 : 多型態別的套用</li>
<li>  如何使用 Rust 標準庫 (io, fs)</li>
<li>  <code>crates</code> : 包的管理 &amp;&amp; 應用 &amp;&amp; 套用</li>
<li><code>async</code> : 異步(非同步)<br>  .<br>  .<br>  .<br>  Rust Note Season I _ 20211128</li>
</ul>
]]></content>
      <categories>
        <category>Rsut</category>
        <category>Rust Season (I)</category>
      </categories>
      <tags>
        <tag>Rust</tag>
        <tag>Rust Basic</tag>
      </tags>
  </entry>
</search>
